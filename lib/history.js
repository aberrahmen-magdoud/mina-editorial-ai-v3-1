"use strict";

import express from "express";
import crypto from "node:crypto";

import { getSupabaseAdmin, sbEnabled } from "./supabase.js";
import { getAuthUser } from "./auth.js";
import { megaEnsureCustomer, megaGetCredits } from "./mega.js";
import { nowIso, safeString } from "./utils.js";

function clampInt(n, min, max) {
  const x = Number(n);
  if (!Number.isFinite(x)) return min;
  return Math.max(min, Math.min(max, Math.floor(x)));
}

function tryParseJson(v) {
  if (!v) return null;
  if (typeof v === "object") return v;
  if (typeof v !== "string") return null;
  const s = v.trim();
  if (!s) return null;
  if (!(s.startsWith("{") || s.startsWith("["))) return null;
  try {
    return JSON.parse(s);
  } catch {
    return null;
  }
}

// IMPORTANT: send only what Profile needs (inputs + assets), remove outputs (provider stuff)
function sanitizeMmaVarsForClient(rawVars) {
  const vars = tryParseJson(rawVars) ?? rawVars ?? null;
  if (!vars || typeof vars !== "object") return null;

  return {
    meta: vars.meta ?? null,
    mode: vars.mode ?? null,
    inputs: vars.inputs ?? null,
    assets: vars.assets ?? null,
    history: vars.history ?? null,
    feedback: vars.feedback ?? null,
    settings: vars.settings ?? null,
    version: vars.version ?? null,
  };
}

// Keep pass:* untouched.
// If you receive a legacy anon-short id (uuid only), normalize it to pass:anon:<uuid>.
function normalizePassId(raw) {
  const s = safeString(raw, "");
  if (!s) return "";
  if (s.startsWith("pass:")) return s;
  return `pass:anon:${s}`;
}

// Build a candidate list so history doesn't look empty due to legacy/passId mismatches.
async function buildPassCandidates({ primaryPassId, authUser, supabase }) {
  const set = new Set();

  const pid = normalizePassId(primaryPassId);
  if (pid) set.add(pid);

  if (pid.startsWith("pass:anon:")) {
    set.add(pid.slice("pass:anon:".length));
  } else if (!pid.startsWith("pass:")) {
    set.add(`pass:anon:${pid}`);
  }

  if (authUser?.email) {
    set.add(`pass:email:${authUser.email}`);
  }

  try {
    if (supabase && (authUser?.email || authUser?.userId)) {
      let q = supabase.from("mega_customers").select("mg_pass_id").limit(50);

      if (authUser?.email && authUser?.userId) {
        const { data: byEmail } = await supabase
          .from("mega_customers")
          .select("mg_pass_id")
          .eq("mg_email", authUser.email)
          .limit(50);
        (byEmail || []).forEach((r) => r?.mg_pass_id && set.add(r.mg_pass_id));

        const { data: byUser } = await supabase
          .from("mega_customers")
          .select("mg_pass_id")
          .eq("mg_user_id", authUser.userId)
          .limit(50);
        (byUser || []).forEach((r) => r?.mg_pass_id && set.add(r.mg_pass_id));
      } else if (authUser?.email) {
        const { data } = await q.eq("mg_email", authUser.email);
        (data || []).forEach((r) => r?.mg_pass_id && set.add(r.mg_pass_id));
      } else if (authUser?.userId) {
        const { data } = await q.eq("mg_user_id", authUser.userId);
        (data || []).forEach((r) => r?.mg_pass_id && set.add(r.mg_pass_id));
      }
    }
  } catch {
    // optional
  }

  return Array.from(set).filter(Boolean).slice(0, 20);
}

export function registerHistoryRoutes(app) {
  const router = express.Router();

  const HISTORY_MAX_ROWS = Number(process.env.HISTORY_MAX_ROWS || 500);
  const HISTORY_PAGE_DEFAULT = Number(process.env.HISTORY_PAGE_DEFAULT || 200);
  const HISTORY_PAGE_MAX = Number(process.env.HISTORY_PAGE_MAX || HISTORY_MAX_ROWS);

  // GET /history/pass/:passId
  router.get("/history/pass/:passId", async (req, res) => {
    const requestId = `hist_${Date.now()}_${crypto.randomUUID()}`;

    try {
      if (!sbEnabled()) return res.status(503).json({ ok: false, requestId, error: "NO_SUPABASE" });

      const supabase = getSupabaseAdmin();
      if (!supabase) return res.status(503).json({ ok: false, requestId, error: "NO_SUPABASE_CLIENT" });

      const authUser = await getAuthUser(req);
      const authPassId = authUser?.userId
        ? normalizePassId(`pass:user:${authUser.userId}`)
        : "";

      const primaryPassId = normalizePassId(authPassId || req.params.passId || "");
      res.set("X-Mina-Pass-Id", primaryPassId);

      // Ensure customer exists (for this passId)
      await megaEnsureCustomer({
        passId: primaryPassId,
        userId: authUser?.userId || null,
        email: authUser?.email || null,
      });

      // Credits for the primary passId
      const { credits, expiresAt } = await megaGetCredits(primaryPassId);

      // Pull history across candidate passIds so it never “looks empty”
      const passIds = await buildPassCandidates({ primaryPassId, authUser, supabase });

      const limit = clampInt(req.query.limit ?? HISTORY_PAGE_DEFAULT, 1, HISTORY_PAGE_MAX);
      const cursor = safeString(req.query.cursor ?? "", "");

      let q = supabase
        .from("mega_generations")
        .select(
          "mg_id, mg_record_type, mg_pass_id, mg_generation_id, mg_session_id, mg_platform, mg_title, mg_type, mg_prompt, mg_output_url, mg_created_at, mg_meta, mg_payload, mg_mma_vars, mg_content_type, mg_mma_mode"
        )
        .in("mg_pass_id", passIds)
        .in("mg_record_type", ["generation", "feedback", "session"])
        .order("mg_created_at", { ascending: false })
        .limit(limit);

      if (cursor) q = q.lt("mg_created_at", cursor);

      const { data, error } = await q;

      if (error) throw error;

      const rows = Array.isArray(data) ? data : [];

      const sessions = rows
        .filter((r) => r.mg_record_type === "session")
        .map((r) => ({
          id: String(r.mg_id || ""),
          sessionId: String(r.mg_session_id || ""),
          passId: String(r.mg_pass_id || primaryPassId),
          platform: String(r.mg_platform || "web"),
          title: r.mg_title ? String(r.mg_title) : "",
          createdAt: String(r.mg_created_at || nowIso()),
        }));

      const generations = rows
        .filter((r) => r.mg_record_type === "generation")
        .map((r) => ({
          id: String(r.mg_id || r.mg_generation_id || ""),
          generationId: String(r.mg_generation_id || ""),
          type: String(r.mg_type || r.mg_content_type || "image"),
          mode: String(r.mg_mma_mode || ""),
          sessionId: String(r.mg_session_id || ""),
          passId: String(r.mg_pass_id || primaryPassId),
          platform: String(r.mg_platform || "web"),
          prompt: String(r.mg_prompt || ""),
          outputUrl: String(r.mg_output_url || ""),
          createdAt: String(r.mg_created_at || nowIso()),
          meta: r.mg_meta ?? null,
          mg_mma_vars: sanitizeMmaVarsForClient(r.mg_mma_vars),
        }));

      const feedbacks = rows
        .filter((r) => r.mg_record_type === "feedback")
        .map((r) => {
          const meta = r.mg_meta && typeof r.mg_meta === "object" ? r.mg_meta : {};
          const payload = meta?.payload && typeof meta.payload === "object" ? meta.payload : meta;

          return {
            id: String(r.mg_id || ""),
            passId: String(r.mg_pass_id || primaryPassId),
            resultType: String(payload.resultType || payload.result_type || "image"),
            platform: String(payload.platform || "web"),
            prompt: String(payload.prompt || ""),
            comment: String(payload.comment || ""),
            imageUrl: payload.imageUrl ? String(payload.imageUrl) : undefined,
            videoUrl: payload.videoUrl ? String(payload.videoUrl) : undefined,
            createdAt: String(r.mg_created_at || nowIso()),
          };
        });

      const nextCursor = rows.length ? String(rows[rows.length - 1].mg_created_at || "") : "";
      const hasMore = rows.length === limit && !!nextCursor;

      return res.json({
        ok: true,
        requestId,
        passId: primaryPassId,
        passIdsChecked: passIds,
        credits: { balance: credits, expiresAt },
        page: {
          limit,
          cursor: cursor || null,
          nextCursor: nextCursor || null,
          hasMore,
          returned: rows.length,
        },
        sessions,
        generations,
        feedbacks,
      });
    } catch (e) {
      console.error("GET /history/pass/:passId failed", e);
      return res.status(500).json({ ok: false, requestId, error: "HISTORY_FAILED", message: e?.message || String(e) });
    }
  });

  // DELETE /history/:id
  router.delete("/history/:id", async (req, res) => {
    const requestId = `del_${Date.now()}_${crypto.randomUUID()}`;

    try {
      if (!sbEnabled()) return res.status(503).json({ ok: false, requestId, error: "NO_SUPABASE" });

      const supabase = getSupabaseAdmin();
      if (!supabase) return res.status(503).json({ ok: false, requestId, error: "NO_SUPABASE_CLIENT" });

      const id = safeString(req.params.id, "");
      if (!id) return res.status(400).json({ ok: false, requestId, error: "MISSING_ID" });

      // Try delete by mg_id first
      const del1 = await supabase.from("mega_generations").delete().eq("mg_id", id).select("mg_id");
      let deleted = Array.isArray(del1.data) ? del1.data.length : 0;

      // Fallback: if frontend sends generationId instead of mg_id
      if (deleted === 0) {
        const del2 = await supabase.from("mega_generations").delete().eq("mg_generation_id", id).select("mg_id");
        deleted = Array.isArray(del2.data) ? del2.data.length : 0;
      }

      return res.json({ ok: true, requestId, deleted: deleted > 0, deletedCount: deleted });
    } catch (e) {
      console.error("DELETE /history/:id failed", e);
      return res.status(500).json({ ok: false, requestId, error: "DELETE_FAILED", message: e?.message || String(e) });
    }
  });

  app.use(router);
}
